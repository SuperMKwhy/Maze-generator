<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deceptive Zigzag Generator & Editor</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f4f7f6; color: #333; }
        h1 { margin: 20px 0; }
        
        .main-container { display: flex; gap: 20px; align-items: flex-start; }
        .canvas-container { 
            position: relative; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); 
            border-radius: 4px; 
            overflow: hidden; 
            background: white;
            border: 2px solid #444; 
        }
        
        canvas { display: block; cursor: crosshair; }
        
        .controls { 
            background: white; padding: 20px; border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.05); width: 280px; 
            display: flex; flex-direction: column; gap: 12px; 
        }
        
        label { font-weight: bold; font-size: 13px; margin-bottom: 2px; display: block; }
        select, button, input { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;}
        button { font-weight: bold; color: white; border: none; cursor: pointer; transition: 0.2s; margin-top: 5px;}
        button:hover { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: wait; }

        .btn-reset { background-color: #6c757d; }
        .btn-test { background-color: #e0a800; }
        .btn-stop { background-color: #dc3545; }
        .btn-gen { background-color: #6f42c1; } 
        .btn-load { background-color: #007bff; }
        .btn-save { background-color: #28a745; }
        .btn-set-start { background-color: #17a2b8; } 
        .btn-set-start.active { background-color: #ffc107; color: #333; animation: pulse 1s infinite; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        .group-box { border: 1px solid #eee; padding: 10px; border-radius: 5px; background: #fafafa; }
        .row { display: flex; gap: 5px; }

        .score-box { padding: 10px; background: #eef; border-radius: 5px; font-family: monospace; font-size: 12px; }
        .score-val { font-weight: bold; color: #007bff; }

        .slider-container { margin-top: 10px; }
        input[type="range"] { width: 100%; margin: 5px 0; cursor: pointer; }
        .slider-val { float: right; color: #6f42c1; font-weight: bold; }
        
        input[type="file"] { display: none; }
    </style>
</head>
<body>

    <h1>MicroMouse: Generator & Editor</h1>

    <div class="main-container">
        
        <div class="controls">
            <!-- Settings -->
            <div class="group-box">
                <label>Maze Size</label>
                <select id="sizeSelect">
                    <option value="16">16 x 16</option>
                    <option value="32">32 x 32</option>
                </select>
                <button class="btn-reset" onclick="resetMaze()">Reset (Clear)</button>
            </div>

            <!-- Seeded Generator -->
            <div class="group-box">
                <label style="color:#6f42c1;">Generator Settings</label>
                
                <label>Algorithm</label>
                <select id="genAlgo">
                    <option value="centershy_zigzag" selected>Center-Shy Zigzag (Hardest)</option>
                    <option value="centershy">Center-Shy (Traps)</option>
                    <option value="dfs_zigzag">DFS (Zigzag Bias)</option>
                    <option value="dfs">Recursive Backtracker</option>
                    <option value="prim">Randomized Prim's</option>
                    <option value="kruskal">Kruskal's Algorithm</option>
                    <option value="aldous">Aldous-Broder (Chaos)</option>
                </select>

                <!-- Wall Density Slider -->
                <div class="slider-container">
                    <label>Wall Density Limit <span id="densityVal" class="slider-val">50%</span></label>
                    <input type="range" id="densitySlider" min="0" max="100" value="50" oninput="document.getElementById('densityVal').innerText = this.value + '%'">
                    <div style="font-size:10px; color:#888; margin-top:2px;">(Applied after generation)</div>
                </div>

                <div class="row" style="margin-top:5px;">
                    <div>
                        <label>Seed</label>
                        <input type="number" id="mazeSeed" value="12345" placeholder="Seed">
                    </div>
                </div>
                
                <button id="genBtn" class="btn-gen" onclick="generateMaze()">Generate Maze</button>
            </div>

            <!-- Simulation -->
            <div class="group-box">
                <label>Solver & Edit</label>
                <select id="algoSelect">
                    <option value="astar">A* (Shortest Path)</option>
                    <option value="flood">Flood Fill (Explore)</option>
                </select>
                <div style="font-size:11px; color:#666; margin:5px 0;">
                    * Click walls to Toggle<br>
                    * Click button below to Move Start
                </div>
                <button id="btnSetStart" class="btn-set-start" onclick="toggleSetStart()">Set Start Point</button>
                <button id="runBtn" class="btn-test" onclick="toggleRun()">Test Solve</button>
            </div>

            <!-- Score -->
            <div id="scorePanel" class="score-box">
                <div>Run Dist: <span id="runDist" class="score-val">0</span></div>
                <div>Run Turns: <span id="runTurns" class="score-val">0</span></div>
                <div style="margin-top:5px; border-top:1px solid #ccc; padding-top:5px;">
                    Best Dist: <span id="bestDist" class="score-val">0</span><br>
                    Best Turns: <span id="bestTurns" class="score-val">0</span>
                </div>
                <div style="margin-top:5px; font-size:14px;">
                    Score: <span id="finalScore" style="color:#d63384; font-weight:bold;">0</span>
                </div>
                <div style="margin-top:5px; border-top:1px solid #ccc; padding-top:5px; font-size:11px;">
                    Actual Density: <span id="actualDensity" style="color:#333;">0%</span>
                </div>
            </div>

            <!-- File IO -->
            <div class="row">
                <input type="file" id="fileInput" accept=".csv">
                <button class="btn-load" onclick="document.getElementById('fileInput').click()">Load</button>
                <button class="btn-save" onclick="saveMaze()">Save</button>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="mazeCanvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const sizeSelect = document.getElementById('sizeSelect');
        const algoSelect = document.getElementById('algoSelect');
        const genAlgoSelect = document.getElementById('genAlgo');
        const runBtn = document.getElementById('runBtn');
        const fileInput = document.getElementById('fileInput');
        const btnSetStart = document.getElementById('btnSetStart');
        const densitySlider = document.getElementById('densitySlider');
        const uiActualDensity = document.getElementById('actualDensity');

        // UI
        const uiRunDist = document.getElementById('runDist');
        const uiRunTurns = document.getElementById('runTurns');
        const uiBestDist = document.getElementById('bestDist');
        const uiBestTurns = document.getElementById('bestTurns');
        const uiFinalScore = document.getElementById('finalScore');
        const inpSeed = document.getElementById('mazeSeed');

        let cellSize = 35;
        let gridSize = 16;
        let grid = []; 
        let startPos = {x: 0, y: 0};
        let goalPositions = [];

        let isRunning = false;
        let isSettingStart = false; 
        let animationId = null;
        let robot = { x: 0, y: 0, dir: 1 }; 
        let pathTrace = [];
        
        let aStarPath = [];
        let aStarIndex = 0;
        let floodMemory = []; 

        // --- Init ---

        function initGridWalls(size) {
            let g = [];
            for(let x=0; x<size; x++) {
                let col = [];
                for(let y=0; y<size; y++) col.push([1, 1, 1, 1]); 
                g.push(col);
            }
            return g;
        }
        
        function initGridEmpty(size) {
            let g = [];
            for(let x=0; x<size; x++) {
                let col = [];
                for(let y=0; y<size; y++) col.push([0, 0, 0, 0]);
                g.push(col);
            }
            for(let i=0; i<size; i++) {
                g[i][size-1][0] = 1; g[size-1][i][1] = 1; 
                g[i][0][2] = 1;      g[0][i][3] = 1;      
            }
            return g;
        }

        function resetMaze() {
            stopSimulation();
            grid = initGridEmpty(gridSize);
            robot = {x:startPos.x, y:startPos.y, dir:1}; 
            pathTrace = [];
            draw();
            updateScoreUI(0,0,0,0);
            updateDensityUI();
        }

        function resizeCanvas() {
            stopSimulation();
            gridSize = parseInt(sizeSelect.value);
            cellSize = gridSize === 32 ? 20 : 35;
            canvas.width = gridSize * cellSize;
            canvas.height = gridSize * cellSize;
            
            let mid = gridSize / 2;
            goalPositions = [
                {x: mid - 1, y: mid - 1}, {x: mid - 1, y: mid},
                {x: mid, y: mid - 1}, {x: mid, y: mid}
            ];
            
            startPos = {x:0, y:0}; 
            grid = initGridEmpty(gridSize);
            draw();
            updateDensityUI();
        }

        // --- INTERACTION LOGIC (Click to Set Start OR Edit Walls) ---
        function toggleSetStart() {
            isSettingStart = !isSettingStart;
            if(isSettingStart) {
                stopSimulation();
                btnSetStart.innerText = "Click Grid Cell...";
                btnSetStart.classList.add('active');
            } else {
                btnSetStart.innerText = "Set Start Point";
                btnSetStart.classList.remove('active');
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Map pixel to grid
            const gx = Math.floor(x / cellSize);
            const gy = gridSize - 1 - Math.floor(y / cellSize);
            
            // Bounds check
            if(gx < 0 || gx >= gridSize || gy < 0 || gy >= gridSize) return;

            // 1. SET START POINT MODE
            if(isSettingStart) {
                if(!isGoal(gx, gy)) {
                    startPos = {x: gx, y: gy};
                    isSettingStart = false;
                    btnSetStart.innerText = "Set Start Point";
                    btnSetStart.classList.remove('active');
                    draw();
                } else {
                    alert("Cannot start inside the goal!");
                }
                return;
            }

            // 2. EDIT WALL MODE (If not setting start)
            // Determine position within the cell (0 to cellSize)
            // Note: Canvas Y is inverted relative to Grid Y visually for calculation
            const cellX = x % cellSize;
            const cellY = y % cellSize;
            const margin = cellSize * 0.25; // Click within 25% of edge to toggle

            // Helper to toggle wall safely
            // Dir: 0=N, 1=E, 2=S, 3=W
            // Canvas Y=0 is Top. Grid Y=Max is Top.
            // cellY small -> Top of visual cell -> North Wall (0)
            
            let toggled = false;

            if(cellY < margin) {
                toggleWall(gx, gy, 0); // North
                toggled = true;
            } else if(cellY > cellSize - margin) {
                toggleWall(gx, gy, 2); // South
                toggled = true;
            } else if(cellX > cellSize - margin) {
                toggleWall(gx, gy, 1); // East
                toggled = true;
            } else if(cellX < margin) {
                toggleWall(gx, gy, 3); // West
                toggled = true;
            }

            if(toggled) {
                stopSimulation(); // Stop run if map changes
                draw();
                updateDensityUI();
            }
        });

        function toggleWall(x, y, dir) {
            // dir: 0=N, 1=E, 2=S, 3=W
            // Prevent removing outer boundary
            if(y === gridSize - 1 && dir === 0) return; // Top edge
            if(x === gridSize - 1 && dir === 1) return; // Right edge
            if(y === 0 && dir === 2) return;            // Bottom edge
            if(x === 0 && dir === 3) return;            // Left edge

            let currentVal = grid[x][y][dir];
            let newVal = currentVal === 1 ? 0 : 1;
            
            grid[x][y][dir] = newVal;

            // Update neighbor
            if(dir === 0 && y < gridSize - 1) grid[x][y+1][2] = newVal; // Neighbor South
            if(dir === 1 && x < gridSize - 1) grid[x+1][y][3] = newVal; // Neighbor West
            if(dir === 2 && y > 0)            grid[x][y-1][0] = newVal; // Neighbor North
            if(dir === 3 && x > 0)            grid[x-1][y][1] = newVal; // Neighbor East
        }

        // --- PRNG ---
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // --- MAZE GENERATORS ---

        function generateMaze() {
            stopSimulation();
            let algo = genAlgoSelect.value;
            let seedVal = parseInt(inpSeed.value) || 999;
            let rng = mulberry32(seedVal);

            grid = initGridWalls(gridSize);

            if (algo === 'centershy_zigzag') runCenterShyZigzagDFS(rng);
            else if (algo === 'centershy') runCenterShyDFS(rng);
            else if (algo === 'dfs_zigzag') runDFSZigzag(rng);
            else if (algo === 'dfs') runDFS(rng);
            else if (algo === 'prim') runPrims(rng);
            else if (algo === 'kruskal') runKruskal(rng);
            else if (algo === 'aldous') runAldousBroder(rng);

            connectSingleGoalEntry(rng);
            enforceWallDensity(rng);

            draw();
            updateDensityUI();
        }

        // --- DENSITY LOGIC ---
        function enforceWallDensity(rng) {
            const maxInternalWalls = 2 * gridSize * (gridSize - 1);
            const desiredPct = parseInt(densitySlider.value) / 100.0;
            const targetWallCount = Math.floor(maxInternalWalls * desiredPct);

            let existingWalls = [];
            for(let x = 0; x < gridSize; x++) {
                for(let y = 0; y < gridSize; y++) {
                    if(y < gridSize - 1 && grid[x][y][0] === 1) existingWalls.push({x:x, y:y, dir:0});
                    if(x < gridSize - 1 && grid[x][y][1] === 1) existingWalls.push({x:x, y:y, dir:1});
                }
            }

            for (let i = existingWalls.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [existingWalls[i], existingWalls[j]] = [existingWalls[j], existingWalls[i]];
            }

            let currentCount = existingWalls.length;
            let index = 0;
            while(currentCount > targetWallCount && index < existingWalls.length) {
                let w = existingWalls[index];
                if(w.dir === 0) removeWall(w.x, w.y, w.x, w.y+1); // Remove N
                else if(w.dir === 1) removeWall(w.x, w.y, w.x+1, w.y); // Remove E
                currentCount--;
                index++;
            }
        }

        function updateDensityUI() {
            let maxInternal = 2 * gridSize * (gridSize - 1);
            let current = 0;
            for(let x=0; x<gridSize; x++) {
                for(let y=0; y<gridSize; y++) {
                    if(y < gridSize - 1 && grid[x][y][0] === 1) current++;
                    if(x < gridSize - 1 && grid[x][y][1] === 1) current++;
                }
            }
            let pct = Math.round((current / maxInternal) * 100);
            uiActualDensity.innerText = pct + "% (" + current + "/" + maxInternal + ")";
        }

        // --- ALGORITHMS ---

        function runCenterShyZigzagDFS(rng) {
            let visited = createVisitedMask();
            let stack = [{x: startPos.x, y: startPos.y}]; 
            visited[startPos.x][startPos.y] = true;       
            let cx = (gridSize / 2) - 0.5; let cy = (gridSize / 2) - 0.5;

            while(stack.length > 0) {
                let current = stack[stack.length - 1];
                let neighbors = getUnvisitedNeighbors(current.x, current.y, visited);
                if(neighbors.length > 0) {
                    let prevDx = 0, prevDy = 0;
                    if(stack.length >= 2) {
                        let parent = stack[stack.length - 2];
                        prevDx = current.x - parent.x; prevDy = current.y - parent.y;
                    }
                    neighbors.forEach(n => {
                        let distScore = Math.abs(n.x - cx) + Math.abs(n.y - cy);
                        let turnBonus = 0;
                        if(prevDx !== 0 || prevDy !== 0) {
                            let ndx = n.x - current.x; let ndy = n.y - current.y;
                            if(ndx !== prevDx || ndy !== prevDy) turnBonus = 100.0;
                        }
                        n.finalScore = (distScore * 10) + turnBonus;
                    });
                    neighbors.sort((a, b) => b.finalScore - a.finalScore);
                    let chosen = (rng() < 0.0) ? neighbors[neighbors.length - 1] : neighbors[0];
                    removeWall(current.x, current.y, chosen.x, chosen.y);
                    visited[chosen.x][chosen.y] = true;
                    stack.push({x: chosen.x, y: chosen.y});
                } else stack.pop();
            }
        }

        function runCenterShyDFS(rng) {
            let visited = createVisitedMask();
            let stack = [{x: startPos.x, y: startPos.y}]; 
            visited[startPos.x][startPos.y] = true;       
            let cx = (gridSize / 2) - 0.5; let cy = (gridSize / 2) - 0.5;
            while(stack.length > 0) {
                let current = stack[stack.length - 1];
                let neighbors = getUnvisitedNeighbors(current.x, current.y, visited);
                if(neighbors.length > 0) {
                    neighbors.sort((a, b) => {
                        let distA = Math.abs(a.x - cx) + Math.abs(a.y - cy);
                        let distB = Math.abs(b.x - cx) + Math.abs(b.y - cy);
                        return distB - distA; 
                    });
                    let chosen = (rng() < 0.25) ? neighbors[neighbors.length-1] : neighbors[0];
                    removeWall(current.x, current.y, chosen.x, chosen.y);
                    visited[chosen.x][chosen.y] = true;
                    stack.push({x: chosen.x, y: chosen.y});
                } else stack.pop();
            }
        }

        function runDFSZigzag(rng) {
            let visited = createVisitedMask();
            let stack = [{x: startPos.x, y: startPos.y}]; 
            visited[startPos.x][startPos.y] = true;       
            while(stack.length > 0) {
                let current = stack[stack.length - 1];
                let neighbors = getUnvisitedNeighbors(current.x, current.y, visited);
                if(neighbors.length > 0) {
                    let chosen = null;
                    if(stack.length >= 2) {
                        let parent = stack[stack.length - 2];
                        let dx = current.x - parent.x; let dy = current.y - parent.y;
                        let straights = [], turns = [];
                        for(let n of neighbors) {
                            let ndx = n.x - current.x; let ndy = n.y - current.y;
                            if(ndx === dx && ndy === dy) straights.push(n); else turns.push(n);
                        }
                        if(turns.length > 0) {
                            if(rng() < 0.95 || straights.length === 0) chosen = turns[Math.floor(rng() * turns.length)];
                            else chosen = straights[0];
                        } else chosen = straights[0];
                    }
                    if(!chosen) chosen = neighbors[Math.floor(rng() * neighbors.length)];
                    removeWall(current.x, current.y, chosen.x, chosen.y);
                    visited[chosen.x][chosen.y] = true;
                    stack.push({x: chosen.x, y: chosen.y});
                } else stack.pop();
            }
        }

        function runDFS(rng) {
            let visited = createVisitedMask();
            let stack = [{x: startPos.x, y: startPos.y}]; 
            visited[startPos.x][startPos.y] = true;       
            while(stack.length > 0) {
                let current = stack[stack.length - 1];
                let neighbors = getUnvisitedNeighbors(current.x, current.y, visited);
                if(neighbors.length > 0) {
                    let chosen = neighbors[Math.floor(rng() * neighbors.length)];
                    removeWall(current.x, current.y, chosen.x, chosen.y);
                    visited[chosen.x][chosen.y] = true;
                    stack.push({x: chosen.x, y: chosen.y});
                } else stack.pop();
            }
        }

        function runPrims(rng) {
            let visited = createVisitedMask();
            let frontier = [];
            visited[startPos.x][startPos.y] = true; 
            addFrontier(startPos.x, startPos.y, visited, frontier); 
            while(frontier.length > 0) {
                let randIndex = Math.floor(rng() * frontier.length);
                let current = frontier[randIndex];
                frontier.splice(randIndex, 1);
                let connected = getVisitedNeighbors(current.x, current.y, visited);
                if(connected.length > 0) {
                    let target = connected[Math.floor(rng() * connected.length)];
                    removeWall(current.x, current.y, target.x, target.y);
                    visited[current.x][current.y] = true;
                    addFrontier(current.x, current.y, visited, frontier);
                }
            }
        }

        function runKruskal(rng) {
            let edges = [];
            let sets = []; let idCounter = 0;
            for(let x=0; x<gridSize; x++) {
                sets[x] = [];
                for(let y=0; y<gridSize; y++) {
                    sets[x][y] = idCounter++;
                    if(x < gridSize-1) edges.push({x1:x, y1:y, x2:x+1, y2:y});
                    if(y < gridSize-1) edges.push({x1:x, y1:y, x2:x, y2:y+1});
                }
            }
            edges = edges.filter(e => !isGoal(e.x1, e.y1) && !isGoal(e.x2, e.y2));
            for(let i = edges.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [edges[i], edges[j]] = [edges[j], edges[i]];
            }
            for(let e of edges) {
                let id1 = getSetID(sets, e.x1, e.y1);
                let id2 = getSetID(sets, e.x2, e.y2);
                if(id1 !== id2) {
                    removeWall(e.x1, e.y1, e.x2, e.y2);
                    replaceSetID(sets, id2, id1);
                }
            }
        }

        function runAldousBroder(rng) {
            let visited = createVisitedMask();
            let remaining = (gridSize * gridSize) - 4; 
            let current = {x: startPos.x, y: startPos.y}; 
            visited[startPos.x][startPos.y] = true; 
            remaining--;
            while(remaining > 0) {
                const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
                let d = dirs[Math.floor(rng() * 4)];
                let nx = current.x + d[0]; let ny = current.y + d[1];
                if(nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                    if(!isGoal(nx, ny)) {
                        if(!visited[nx][ny]) {
                            visited[nx][ny] = true;
                            removeWall(current.x, current.y, nx, ny);
                            remaining--;
                        }
                        current = {x: nx, y: ny};
                    }
                }
            }
        }

        // --- HELPERS ---

        function createVisitedMask() {
            let v = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
            goalPositions.forEach(p => v[p.x][p.y] = true);
            return v;
        }

        function getUnvisitedNeighbors(x, y, visited) {
            let n = [];
            const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
            for(let d of dirs) {
                let nx = x + d[0], ny = y + d[1];
                if(nx>=0 && nx<gridSize && ny>=0 && ny<gridSize) {
                    if(!visited[nx][ny]) n.push({x: nx, y: ny});
                }
            }
            return n;
        }

        function addFrontier(x, y, visited, frontier) {
            const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
            for(let d of dirs) {
                let nx = x + d[0], ny = y + d[1];
                if(nx>=0 && nx<gridSize && ny>=0 && ny<gridSize) {
                    if(!visited[nx][ny]) {
                        if(!frontier.some(f => f.x===nx && f.y===ny)) frontier.push({x: nx, y: ny});
                    }
                }
            }
        }

        function getVisitedNeighbors(x, y, visited) {
            let n = [];
            const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
            for(let d of dirs) {
                let nx = x + d[0], ny = y + d[1];
                if(nx>=0 && nx<gridSize && ny>=0 && ny<gridSize) {
                    if(visited[nx][ny]) n.push({x: nx, y: ny});
                }
            }
            return n;
        }

        function getSetID(sets, x, y) { return sets[x][y]; }
        function replaceSetID(sets, oldID, newID) {
            for(let x=0; x<gridSize; x++) {
                for(let y=0; y<gridSize; y++) {
                    if(sets[x][y] === oldID) sets[x][y] = newID;
                }
            }
        }

        function removeWall(x1, y1, x2, y2) {
            let dx = x2 - x1, dy = y2 - y1;
            let d1 = -1, d2 = -1;
            if(dy===1){d1=0;d2=2;} else if(dx===1){d1=1;d2=3;}
            else if(dy===-1){d1=2;d2=0;} else if(dx===-1){d1=3;d2=1;}
            
            if(d1!==-1) {
                grid[x1][y1][d1] = 0;
                grid[x2][y2][d2] = 0;
            }
        }

        function connectSingleGoalEntry(rng) {
            for(let i=0; i<goalPositions.length; i++) {
                for(let j=i+1; j<goalPositions.length; j++) {
                    if(Math.abs(goalPositions[i].x - goalPositions[j].x) + Math.abs(goalPositions[i].y - goalPositions[j].y) === 1) {
                        removeWall(goalPositions[i].x, goalPositions[i].y, goalPositions[j].x, goalPositions[j].y);
                    }
                }
            }
            let candidates = [];
            const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
            goalPositions.forEach(gp => {
                dirs.forEach(d => {
                    let nx = gp.x + d[0], ny = gp.y + d[1];
                    if(nx>=0 && nx<gridSize && ny>=0 && ny<gridSize) {
                        if(!isGoal(nx, ny)) candidates.push({srcX: gp.x, srcY: gp.y, tgtX: nx, tgtY: ny});
                    }
                });
            });
            if(candidates.length > 0) {
                let c = candidates[Math.floor(rng() * candidates.length)];
                removeWall(c.srcX, c.srcY, c.tgtX, c.tgtY);
            }
        }

        // --- SOLVER ---

        function toggleRun() {
            if(isRunning) stopSimulation();
            else startSimulation();
        }

        function stopSimulation() {
            isRunning = false;
            cancelAnimationFrame(animationId);
            runBtn.innerText = "Test Solve";
            runBtn.className = "btn-test";
        }

        function startSimulation() {
            isRunning = true;
            runBtn.innerText = "Stop Solve";
            runBtn.className = "btn-stop";
            
            robot = {x: startPos.x, y: startPos.y, dir: 1};
            pathTrace = [{x: startPos.x, y: startPos.y}];

            if(algoSelect.value === 'astar') {
                aStarPath = solveAStar(grid, startPos);
                aStarIndex = 0;
            } else {
                floodMemory = initGridEmpty(gridSize); 
            }
            loopSolver();
        }

        function loopSolver() {
            if(!isRunning) return;

            let moved = false;
            if(!isGoal(robot.x, robot.y)) {
                if(algoSelect.value === 'astar') {
                    if(aStarPath.length > 0 && aStarIndex < aStarPath.length) {
                        let next = aStarPath[aStarIndex++];
                        robot.dir = getDirection(robot, next); 
                        robot.x = next.x;
                        robot.y = next.y;
                        moved = true;
                    }
                } else {
                    moved = stepFloodFill();
                }
            }

            if(moved) {
                pathTrace.push({x:robot.x, y:robot.y});
            }

            let runM = getMetrics(pathTrace);
            let bestM = getMetrics(solveAStar(grid, startPos));
            updateScoreUI(runM.dist, runM.turns, bestM.dist, bestM.turns);

            draw();

            if(moved) {
                setTimeout(() => { animationId = requestAnimationFrame(loopSolver); }, 40); 
            } else if (!isGoal(robot.x, robot.y)) {
                 requestAnimationFrame(loopSolver);
            }
        }

        // --- HELPERS ---
        function getDirection(a, b) {
            let dx = b.x - a.x;
            let dy = b.y - a.y;
            if(dy === 1) return 0; if(dx === 1) return 1;
            if(dy === -1) return 2; if(dx === -1) return 3;
            return a.dir;
        }

        function solveAStar(targetGrid, startObj) {
            let start = startObj || {x:0, y:0};
            let openSet = [{x:start.x, y:start.y, g:0, f:0, parent:null}];
            let closed = new Set();
            let centerCoord = (gridSize / 2) - 0.5;
            while(openSet.length) {
                openSet.sort((a,b)=>a.f - b.f);
                let u = openSet.shift();
                if(isGoal(u.x, u.y)) {
                    let path = [];
                    while(u) { path.push({x:u.x, y:u.y}); u = u.parent; }
                    return path.reverse();
                }
                let k = `${u.x},${u.y}`;
                if(closed.has(k)) continue;
                closed.add(k);
                const dirs = [[0,1,0], [1,0,1], [0,-1,2], [-1,0,3]]; 
                for(let d of dirs) {
                    let nx = u.x + d[0], ny = u.y + d[1], wIdx = d[2];
                    if(nx>=0 && nx<gridSize && ny>=0 && ny<gridSize) {
                        if(targetGrid[u.x][u.y][wIdx] === 0) {
                            if(!closed.has(`${nx},${ny}`)) {
                                let g = u.g + 1;
                                let h = Math.abs(nx - centerCoord) + Math.abs(ny - centerCoord);
                                openSet.push({x:nx, y:ny, g:g, f:g+h, parent:u});
                            }
                        }
                    }
                }
            }
            return [];
        }

        function stepFloodFill() {
            let x = robot.x, y = robot.y;
            let real = grid[x][y];
            floodMemory[x][y] = [...real];
            if(y<gridSize-1) floodMemory[x][y+1][2] = real[0];
            if(x<gridSize-1) floodMemory[x+1][y][3] = real[1];
            if(y>0)          floodMemory[x][y-1][0] = real[2];
            if(x>0)          floodMemory[x-1][y][1] = real[3];
            let dist = Array(gridSize).fill().map(()=>Array(gridSize).fill(9999));
            let q = [];
            goalPositions.forEach(g => { if(g.x<gridSize && g.y<gridSize) { dist[g.x][g.y]=0; q.push(g); } });
            while(q.length) {
                let u = q.shift();
                let dVal = dist[u.x][u.y];
                let walls = floodMemory[u.x][u.y];
                const dirs = [[0,1,0], [1,0,1], [0,-1,2], [-1,0,3]];
                for(let d of dirs) {
                    if(walls[d[2]] === 0) {
                        let nx = u.x + d[0], ny = u.y + d[1];
                        if(nx>=0 && nx<gridSize && ny>=0 && ny<gridSize) {
                            if(dist[nx][ny] === 9999) { dist[nx][ny] = dVal + 1; q.push({x:nx, y:ny}); }
                        }
                    }
                }
            }
            let minD = 9999, next = null;
            let myWalls = floodMemory[x][y];
            const moves = [{x:x, y:y+1, w:0}, {x:x+1, y:y, w:1}, {x:x, y:y-1, w:2}, {x:x-1, y:y, w:3}];
            for(let m of moves) {
                if(m.x>=0 && m.x<gridSize && m.y>=0 && m.y<gridSize) {
                    if(myWalls[m.w] === 0) {
                        let d = dist[m.x][m.y];
                        if(d < minD) { minD = d; next = m; }
                    }
                }
            }
            if(next && minD < 9999) { 
                let dir = getDirection(robot, next);
                if(dir !== -1) robot.dir = dir;
                robot.x = next.x; robot.y = next.y; return true; 
            }
            return false;
        }

        function getMetrics(path) {
            if(!path || path.length < 2) return {dist:0, turns:0};
            let dist = path.length - 1, turns = 0;
            let dir = {dx:0, dy:1}; 
            for(let i=0; i<path.length-1; i++) {
                let dx = path[i+1].x - path[i].x;
                let dy = path[i+1].y - path[i].y;
                if(dx !== dir.dx || dy !== dir.dy) turns++;
                dir = {dx, dy};
            }
            return {dist, turns};
        }

        function updateScoreUI(rd, rt, bd, bt) {
            uiRunDist.innerText = rd; uiRunTurns.innerText = rt;
            uiBestDist.innerText = bd; uiBestTurns.innerText = bt;
            let score = (bd + bt) + 0.1 * (rd + rt);
            uiFinalScore.innerText = score.toFixed(2);
        }

        function isGoal(x, y) {
            return goalPositions.some(g => g.x === x && g.y === y);
        }

        // --- DRAWING ---

        function getCanvasPos(x, y) {
            return { px: x * cellSize, py: (gridSize - 1 - y) * cellSize };
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Highlights
            drawCell(startPos.x, startPos.y, "#C8E6C9"); 

            goalPositions.forEach(p => {
                if(p.x < gridSize && p.y < gridSize) drawCell(p.x, p.y, "#FFEBEE");
            });
            // Grid
            ctx.lineWidth = 1; ctx.strokeStyle = "#eee"; ctx.beginPath();
            for(let i=0; i<=gridSize; i++) {
                ctx.moveTo(0, i*cellSize); ctx.lineTo(gridSize*cellSize, i*cellSize);
                ctx.moveTo(i*cellSize, 0); ctx.lineTo(i*cellSize, gridSize*cellSize);
            }
            ctx.stroke();
            // Trace
            if(pathTrace.length > 1) {
                ctx.lineWidth = 3; ctx.strokeStyle = "rgba(0, 123, 255, 0.5)";
                ctx.beginPath();
                let s = getCanvasPos(pathTrace[0].x, pathTrace[0].y);
                ctx.moveTo(s.px+cellSize/2, s.py+cellSize/2);
                for(let i=1; i<pathTrace.length; i++) {
                    let p = getCanvasPos(pathTrace[i].x, pathTrace[i].y);
                    ctx.lineTo(p.px+cellSize/2, p.py+cellSize/2);
                }
                ctx.stroke();
            }
            // Walls
            ctx.lineWidth = 4; ctx.strokeStyle = "#222"; ctx.lineCap = "round"; ctx.beginPath();
            for(let x=0; x<gridSize; x++) {
                for(let y=0; y<gridSize; y++) {
                    let w = grid[x][y];
                    let pos = getCanvasPos(x, y);
                    let px = pos.px, py = pos.py;
                    if(w[0]) { ctx.moveTo(px, py); ctx.lineTo(px+cellSize, py); }
                    if(w[1]) { ctx.moveTo(px+cellSize, py); ctx.lineTo(px+cellSize, py+cellSize); }
                    if(w[2]) { ctx.moveTo(px, py+cellSize); ctx.lineTo(px+cellSize, py+cellSize); }
                    if(w[3]) { ctx.moveTo(px, py); ctx.lineTo(px, py+cellSize); }
                }
            }
            ctx.stroke();
            // Robot
            drawRobot();
        }

        function drawRobot() {
            let cur = robot; 
            if(isRunning && pathTrace.length > 0) cur = Object.assign({}, pathTrace[pathTrace.length-1], {dir: robot.dir});
            
            let pos = getCanvasPos(cur.x, cur.y);
            let cx = pos.px + cellSize/2;
            let cy = pos.py + cellSize/2;
            let size = cellSize / 3;

            ctx.fillStyle = "#007bff";
            ctx.beginPath();
            ctx.save();
            ctx.translate(cx, cy);
            
            let angle = 0;
            if(cur.dir === 1) angle = Math.PI/2;
            else if(cur.dir === 2) angle = Math.PI;
            else if(cur.dir === 3) angle = -Math.PI/2;
            
            ctx.rotate(angle);
            ctx.moveTo(0, -size); 
            ctx.lineTo(size, size); 
            ctx.lineTo(-size, size); 
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawCell(x, y, color) {
            let pos = getCanvasPos(x, y); ctx.fillStyle = color; ctx.fillRect(pos.px, pos.py, cellSize, cellSize);
        }

        // --- File IO ---
        function saveMaze() {
            fetch('/generate_csv', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({size: gridSize, grid: grid})
            })
            .then(r=>r.blob()).then(blob=>{
                let url = URL.createObjectURL(blob);
                let a = document.createElement('a'); a.href = url; a.download = 'maze.csv';
                document.body.appendChild(a); a.click(); a.remove();
            });
        }

        fileInput.addEventListener('change', (e) => {
            let f = e.target.files[0]; if(!f) return;
            let fd = new FormData(); fd.append('file', f);
            fetch('/load_csv', {method:'POST', body:fd})
            .then(r=>r.json()).then(d=>{
                if(d.error) alert(d.error); else {
                    stopSimulation(); sizeSelect.value = d.size; resizeCanvas(); 
                    grid = d.grid; draw();
                    updateDensityUI();
                }
            });
            fileInput.value='';
        });

        sizeSelect.addEventListener('change', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>